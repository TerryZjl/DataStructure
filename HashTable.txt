#ifndef _HASHTABLE_H_
#define _HASHTABLE_H_

#include<iostream>
#include<vector>
using namespace std;

///// @brief SDBM Hash Function  
/// @detail 本算法是由于在开源项目SDBM（一种简单的数据库引擎）中被应用而得名，它与BKDRHash思想一致，只是种子不同而已。  
template<class T>
size_t SDBMHash(const T *str)
{
	register size_t hash = 0;
	while (size_t ch = (size_t)*str++)
	{
		hash = 65599 * hash + ch;
		//hash = (size_t)ch + (hash << 6) + (hash << 16) - hash;  
	}
	return hash;
}

template<class K>
struct Com
{
	size_t operator()(const K& key)
	{
		return key;
	}
};

template<>
struct Com<string>
{
	size_t operator()(const char* key)
	{
		return SDBMHash(key);
	}
};

//使用素数表对齐做哈希表的容量，降低哈希冲突
const int _PrimeSize = 28;
static const unsigned long _PrimeList[_PrimeSize] =
{
	53ul, 97ul, 193ul, 389ul, 769ul,
	1543ul, 3079ul, 6151ul, 12289ul, 24593ul,
	49157ul, 98317ul, 196613ul, 393241ul,
	786433ul,
	1572869ul, 3145739ul, 6291469ul, 12582917ul,
	25165843ul,
	50331653ul, 100663319ul, 201326611ul, 402653189ul,
	805306457ul,
	1610612741ul, 3221225473ul, 4294967291ul
};

enum state
{
	EXIST,
	EMPTY,
	DELETED
};


template<class K, class V>
struct HashNode
{
	state _state;
	pair<K, V> _kv;
	HashNode()
		:_state(EMPTY)
	{}
};
//开放定值法
template<class K,class V,class Compere = Com<K>>
class HashTable
{
	typedef HashNode<K, V> Node;
public:
	HashTable()
		:_size(0)
	{}
	bool Insert(const pair<K, V>& x)
	{
		AddCapacity();//判断增容，并深拷贝

		size_t len = _v.size();
		size_t index = HashFunc(x.first);//除留余数法求下标
		size_t i = 1;
		int num = index; //保存第一次计算的下标位置，方便二次探测
		while (_v[index]._state == EXIST)
		{
			if(_v[index]._kv.first == x.first)//不允许Key值冗余
			{
				cout << x.first << "已存在，插入失败" << endl;
				return false;
			}
			//线性探测
			//++index;
			//++i;
			//if (index == len)
			//	index = index%len;

			//二次探测
			index = num + (i*i);
			++i;
			if (index == len)
				index = index%len;
		}
		_v[index]._kv = x;
		_v[index]._state = EXIST;
		++_size;
		cout << _v[index]._kv.first<< ":插入成功" << endl;
		return true;
		
	}


	Node* Find(const K& key)
	{
		size_t index = HashFunc(key);
		size_t len = _v.size();
		int i = 1;
		int num = index;
		while (_v[index]._state != EMPTY)
		{
			if (_v[index]._state == EXIST)
			{
				if (_v[index]._kv.first == key)
					return &_v[index];
			}
			////线性探测
			//++index;
			//if (index == len)
			//	index = index%len;

			//二次探测
			index = num + (i*i);
			++i;
			if (index == len)
				index = index%len;
		}
		return NULL;
	}
	bool Erase(const K& key)
	{
		Node* cur = Find(key);
		if (cur != NULL)
		{
			size_t index = cur->_kv.first;
			_v[index]._state = EMPTY;
			return true;
		}
		else
		{
			return false;
		}
	}

	size_t Size()
	{
		return _size;
	}
	size_t Capacity()
	{
		return _v.size();
	}
private:
	size_t HashFunc(const K& x)
	{
		Compere hf;
		string str = x;
		return hf(str.c_str()) % _v.size();
	}
	void AddCapacity()
	{
		size_t TableLen = _v.size();
		if (TableLen == 0)   //如果表长为0，则直接增容
		{
			size_t NewTableLen = GetCapacity(0);
			_v.resize(NewTableLen);
			return;
		}
		if ((_size * 10) / (TableLen * 10) > 7)  //计算增容并深拷贝数据
		{
			size_t NewTableLen = GetCapacity(TableLen);
			HashTable<K, V> NewHt;
			NewHt._v.resize(NewTableLen);
			for (int i = 0; i < TableLen; i++)
			{
				NewHt.Insert(_v[i]._kv);
			}
			_v.swap(NewHt._v);
		}
	}

	size_t GetCapacity(size_t OldLen)
	{
		for (int i = 0; i < _PrimeSize; i++)
		{
			if (OldLen < _PrimeList[i])
			{
				return _PrimeList[i];
			}
		}
		return _PrimeList[_PrimeSize-1];
	}
private:
	vector<Node> _v;
	size_t _size;  //表里面存数据的个数
};

void TestHashTable()
{
	//HashTable<int,int> ht;
	//ht.Insert(make_pair(1, 2));
	//ht.Insert(make_pair(3, 2));
	//ht.Insert(make_pair(5, 2));
	//ht.Insert(make_pair(7, 2));
	//ht.Insert(make_pair(23, 2));


	//ht.Insert(make_pair(3, 2));
	//ht.Insert(make_pair(3, 2));
	//ht.Insert(make_pair(3, 2));
	//ht.Insert(make_pair(3, 2));
	//ht.Insert(make_pair(17, 2));
	//ht.Erase(17);
	//ht.Insert(make_pair(17,2));
	//HashNode<int,int>* ret = ht.Find(16);
	//if (ret)
	//	cout << ret->_kv.first <<":"<< ret->_kv.second << endl;
	HashTable<string, string> ht2;
	ht2.Insert(make_pair("张三", "zhangsan"));
	ht2.Insert(make_pair("李四", "lisi"));
	ht2.Insert(make_pair("王麻子", "wangmazi"));
	ht2.Insert(make_pair("字符串", "string"));
	HashNode<string, string>* ret = ht2.Find("李四");
	if (ret)
		cout << ret->_kv.second << endl;

}

#endif //_HASHTABLE_H_
#ifndef _HASHTABLE_H_
#define _HASHTABLE_H_

#include<iostream>
#include<vector>
using namespace std;



//使用素数表对齐做哈希表的容量，降低哈希冲突
const int _PrimeSize = 28;
static const unsigned long _PrimeList[_PrimeSize] =
{
	53ul, 97ul, 193ul, 389ul, 769ul,
	1543ul, 3079ul, 6151ul, 12289ul, 24593ul,
	49157ul, 98317ul, 196613ul, 393241ul,
	786433ul,
	1572869ul, 3145739ul, 6291469ul, 12582917ul,
	25165843ul,
	50331653ul, 100663319ul, 201326611ul, 402653189ul,
	805306457ul,
	1610612741ul, 3221225473ul, 4294967291ul
};

enum state
{
	EXIST,
	EMPTY,
	DELETED
};


template<class K, class V>
struct HashNode
{
	state _state;
	pair<K, V> _kv;
	HashNode()
		:_state(EMPTY)
	{}
};
//开放定值法
template<class K,class V>
class HashTable
{
	typedef HashNode<K, V> Node;
public:
	HashTable()
		:_size(0)
	{}
	void Insert(const pair<K, V>& x)
	{
		Capacity();

		size_t len = _v.size();
		size_t index = HashFunc(x.first);
		size_t i = 1;
		int num = index; //保存第一次计算的下标位置，方便二次探测
		while (i<len&&_v[index]._state == EXIST)
		{
			//线性探测
			//++index;
			//++i;
			//if (index == len)
			//	index = index%len;

			//二次探测
		
	 		index = num + (i*i);
			++i;
			if (index == len)
				index = index%len;
		}
		if (_v[index]._state == EXIST)
		{
			cout << "插入失败" << endl;
		}
		else
		{
			_v[index]._kv = x;
			_v[index]._state = EXIST;
		}
	}
	void Capacity()
	{
		size_t TableLen = _v.size();
		if (TableLen == 0)   //如果表长为0，则直接增容
		{
			size_t NewTableLen =  GetCapacity(TableLen);
			_v.resize(NewTableLen);
			return;
		}
		if ((_size * 10) / (TableLen * 10) > 7)  //计算增容并深拷贝数据
		{
			size_t NewTableLen = GetCapacity(TableLen);
			HashTable<K,V> NewHt;
			NewHt._v.resize(NewTableLen);
			for (int i = 0; i < TableLen; i++)
			{
				NewHt.Insert(_v[i]._kv);
			}
			_v.swap(NewHt._v);
		}
	}

	size_t GetCapacity(size_t OldLen)
	{
		if (OldLen == 0)
		{
			return _PrimeList[0];
		}
		int i = 0;
		for (i = 0; i < 28; i++)
		{
			if ((_size * 10) / (_PrimeList[i] * 10) <= 7)
			{
				return _PrimeList[i];
			}
		}
		return _PrimeList[i - 1];
	}

	size_t HashFunc(const K& x)
	{
		return x % _v.size();
	}
private:
	vector<Node> _v;
	size_t _size;  //表里面存数据的个数
};

void TestHashTable()
{
	HashTable<int,int> ht;
	ht.Insert(make_pair(1, 2));
	ht.Insert(make_pair(3, 2));
	ht.Insert(make_pair(5, 2));
	ht.Insert(make_pair(7, 2));
	ht.Insert(make_pair(23, 2));


	ht.Insert(make_pair(3, 2));
	ht.Insert(make_pair(3, 2));
	ht.Insert(make_pair(3, 2));
	ht.Insert(make_pair(3, 2));
	ht.Insert(make_pair(17, 2));
}

#endif //_HASHTABLE_H_